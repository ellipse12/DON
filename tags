!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/ellipse12/Projects/cpp/EDN/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
$(build)	Makefile	/^$(build):$/;"	t
$(build)/$(out)	Makefile	/^$(build)\/$(out): $(files) $(libs) $(build)$/;"	t
$(build)/%.o	Makefile	/^$(build)\/%.o: $(src)\/%.cpp$/;"	t
ASSIGN	src/parser.cpp	/^    ASSIGN,$/;"	e	enum:TokenType	file:
CC	Makefile	/^CC=g++$/;"	m
DON	README.md	/^# DON$/;"	c
EDNNull	include/EON.h	/^struct EDNNull{};$/;"	s
EDNObject	include/EON.h	/^struct EDNObject{$/;"	s
EDNValue	include/EON.h	/^struct EDNValue{$/;"	s
ID	src/parser.cpp	/^    ID,$/;"	e	enum:TokenType	file:
LBRACK	src/parser.cpp	/^    LBRACK,$/;"	e	enum:TokenType	file:
LITERAL	src/parser.cpp	/^    LITERAL,$/;"	e	enum:TokenType	file:
RBRACK	src/parser.cpp	/^    RBRACK$/;"	e	enum:TokenType	file:
Scanner	src/parser.cpp	/^struct Scanner{$/;"	s	file:
Token	src/parser.cpp	/^struct Token{$/;"	s	file:
TokenType	src/parser.cpp	/^enum TokenType{$/;"	g	file:
assign	src/parser.cpp	/^void assign(Scanner* scanner, EDNObject* document){$/;"	f	typeref:typename:void
clean	Makefile	/^clean:$/;"	t
consume	src/parser.cpp	/^    Token consume(){$/;"	f	struct:Scanner	typeref:typename:Token	file:
cursor	src/parser.cpp	/^    int cursor;$/;"	m	struct:Scanner	typeref:typename:int	file:
expect	src/parser.cpp	/^    Token expect(TokenType type){$/;"	f	struct:Scanner	typeref:typename:Token	file:
expr	src/parser.cpp	/^EDNValue* expr(Scanner* scanner){$/;"	f	typeref:typename:EDNValue *
files	Makefile	/^files := $(subst src, build, $(patsubst %.cpp, %.o, $(wildcard $(src)\/*.cpp)))$/;"	m
flags	Makefile	/^flags=-g $(incl)$/;"	m
get	src/parser.cpp	/^    Token get(){$/;"	f	struct:Scanner	typeref:typename:Token	file:
has_next	src/parser.cpp	/^    bool has_next(){$/;"	f	struct:Scanner	typeref:typename:bool	file:
incl	Makefile	/^incl:=-Iinclude\/ $/;"	m
is_next	src/parser.cpp	/^    bool is_next(TokenType type){$/;"	f	struct:Scanner	typeref:typename:bool	file:
lex	src/parser.cpp	/^std::vector<Token> lex(std::string input){$/;"	f	typeref:typename:std::vector<Token>
libs	Makefile	/^libs := $/;"	m
line	src/parser.cpp	/^    int line;$/;"	m	struct:Token	typeref:typename:int	file:
main	src/main.cpp	/^int main(int argc, char* argv[]){$/;"	f	typeref:typename:int
next_if	src/parser.cpp	/^    bool next_if(TokenType type){$/;"	f	struct:Scanner	typeref:typename:bool	file:
object	include/EON.h	/^    std::unordered_map<std::string, EDNValue*> object;$/;"	m	struct:EDNObject	typeref:typename:std::unordered_map<std::string,EDNValue * >
out	Makefile	/^out=out$/;"	m
parse	src/parser.cpp	/^void parse(std::string input, EDNObject* document){$/;"	f	typeref:typename:void
peek	src/parser.cpp	/^    Token peek(){$/;"	f	struct:Scanner	typeref:typename:Token	file:
pprint	src/pretty_print.cpp	/^std::string pprint(EDNObject* object){$/;"	f	typeref:typename:std::string
pprint	src/pretty_print.cpp	/^std::string pprint(EDNValue object){$/;"	f	typeref:typename:std::string
print_token	src/parser.cpp	/^std::string print_token(Token token){$/;"	f	typeref:typename:std::string
print_token_type	src/parser.cpp	/^std::string print_token_type(TokenType ttype){$/;"	f	typeref:typename:std::string
run	Makefile	/^run:$/;"	t
src	Makefile	/^src=src$/;"	m
tokens	src/parser.cpp	/^    std::vector<Token> tokens;$/;"	m	struct:Scanner	typeref:typename:std::vector<Token>	file:
type	src/parser.cpp	/^    TokenType type;$/;"	m	struct:Token	typeref:typename:TokenType	file:
value	include/EON.h	/^    std::variant<long, double, std::string, bool, EDNNull, EDNObject*> value;$/;"	m	struct:EDNValue	typeref:typename:std::variant<long,double,std::string,bool,EDNNull,EDNObject * >
value	src/parser.cpp	/^    EDNValue value;$/;"	m	struct:Token	typeref:typename:EDNValue	file:
writes	src/parser.cpp	/^EDNObject* writes(std::string input){$/;"	f	typeref:typename:EDNObject *
